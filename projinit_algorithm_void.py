# -*- coding: utf-8 -*-

"""
/***************************************************************************
 procplug1
                                 A QGIS plugin
 This is a first attempt at a processing plugin for the O&P Project Initiation GUI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-16
        copyright            : (C) 2023 by Tyler Martin
        email                : tyler.smconsulting@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Tyler Martin'
__date__ = '2023-06-16'
__copyright__ = '(C) 2023 by Tyler Martin'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from osgeo import gdal, osr, ogr
import shutil
import datetime
import platform
import requests
import rasterio
from rasterio import windows, merge
import rasterio.coords
from rasterio.coords import disjoint_bounds
import geopandas as gpd
import numpy as np
import skimage
import shapely.geometry
from shapely.wkt import dumps
from shapely.geometry import Point, mapping
from requests import utils
import processing
import os
from qgis.core import (
    QgsApplication,
    QgsDataSourceUri,
    QgsCategorizedSymbolRenderer,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsClassificationRange,
    QgsPointXY,
    QgsProject,
    QgsExpression,
    QgsField,
    QgsFields,
    QgsFeature,
    QgsFeatureRequest,
    QgsFeatureRenderer,
    QgsRasterLayer,
    QgsGeometry,
    QgsGraduatedSymbolRenderer,
    QgsJsonUtils,
    QgsLayerTreeLayer,
    QgsProcessing,
    QgsProcessingParameterString,
    QgsProcessingAlgorithm,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterFileDestination,
    QgsProcessingOutputFile,
    QgsMarkerSymbol,
    QgsMessageLog,
    QgsRasterPipe,
    QgsRectangle,
    QgsRasterFileWriter,
    QgsRendererCategory,
    QgsRendererRange,
    QgsSymbol,
    QgsVectorDataProvider,
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsWkbTypes,
    QgsSpatialIndex,
    QgsVectorLayerUtils
)


class procplug1Algorithm(QgsProcessingAlgorithm):
    """
    This is my attempt at a functional QGIS plugin for project creation at Omsberg & Preston
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT_PARAM1 = 'proj_apn'
    INPUT_PARAM2 = 'client_name'
    INPUT_PARAM3 = 'proj_num'
    INPUT_PARAM4 = 'other_proj'
    INPUT_PARAM5 = 'proj_type'
    OP_PROJECT_FILE = 'OP_PROJECT_FILE'

    def initAlgorithm(self, config, **kwargs):

        self.addParameter(
            QgsProcessingParameterString(
                self.INPUT_PARAM3,
                self.tr('Project Number:'),
                defaultValue=""
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.INPUT_PARAM1,
                self.tr('Project APN (XXX-XXX-XXX-000):'),
                defaultValue=""
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.INPUT_PARAM2,
                self.tr('Client Name:'),
                defaultValue=str("")
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.INPUT_PARAM4,
                self.tr('Check box if this is for a test or does not need to go in O:/Projects_Civil3D\n...it will be'
                        'placed in {P:/_Information/OP_PROJECT_CREATOR/Destination} instead!\n'
                        'USE THIS OPTION FOR NEW PROPOSALS UNTIL I IMPLEMENT PROPOSAL FUNCTIONALITY'),
                defaultValue=False
            )
        )
        """
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.INPUT_PARAM5,
                self.tr('Check box if this is a proposal'),
                defaultValue=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFileDestination(
                'ProjectFile',
                self.tr('Output QGIS Project File'),
                fileFilter='QGIS Project Files (*.qgs *.qgz)'
            )
        )
        """
        # Define the output parameter for the project file
        self.addOutput(
            QgsProcessingOutputFile(
                self.OP_PROJECT_FILE,
                self.tr('Project file')
            )
        )
        """
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OP_PROJECT_FILE,  # The unique identifier of the parameter
                "Project File",  # The name of the parameter
            )
        )
        """
    proj_apn = INPUT_PARAM1
    client_name = INPUT_PARAM2
    proj_num = INPUT_PARAM3
    other_proj = INPUT_PARAM4
    proj_type = INPUT_PARAM5

    # initAlgorithm()

    def processAlgorithm(self, parameters, context, feedback, **kwargs):
        global project_file
        """
        Here is where the processing itself takes place.
        :param feedback:
        :param parameters:
        :param context:
        """

        feedback.setProgress(5)

        # Project parameters
        today = datetime.datetime.now()
        buffer_radius = 5000  # For DEM and SHP selection
        buffer_distance = 5000  # Buffer selection of parcels
        buffer_dem = 2000  # Buffer for DEM and contours

        def execute_code():
            # noinspection PyGlobalUndefined
            global source_shp, destination_shp, qgis_path, r_layer1, destination_ras, dwg_folder, prj_folder, \
                output_dst, proposal_check, raster_file, input_epsg, dem1m, layer, proj_apn, proj_num, proj_type, \
                client_name, buffer_layer, project_file, dst_file, layer_name, other_proj
            # proj_num = proj_num_entry.get()
            # proj_apn = proj_apn_entry.get()
            # client_name = client_name_entry.get()
            proj_apn = self.parameterAsString(parameters, self.INPUT_PARAM1, context)
            client_name = self.parameterAsString(parameters, self.INPUT_PARAM2, context)
            proj_num = self.parameterAsString(parameters, self.INPUT_PARAM3, context)
            # proj_type = self.parameterAsBool(parameters, self.INPUT_PARAM4, context)
            other_proj = self.parameterAsBool(parameters, self.INPUT_PARAM5, context)
            proj_type = False

            # Project defaults for easy debug
            # QgsMessageLog.logMessage()

            feedback.setProgress(7)

            # Source and destination file locations for Home
            if platform == "linux":
                lin_dst = "/media/storage/JavaTest/Destination/"
                output_dst = lin_dst
                source_shp = "/media/storage/JavaTest/Source/"
                qgis_path = "/usr"

            if platform == "win32" or platform == "Windows":
                # win_dst = "D:/JavaTest/Destination/"
                win_dst = "T:/JavaTest/Destination/"
                output_dst = win_dst
                # source_shp = "D:/JavaTest/Source/"
                source_shp = "T:/JavaTest/Source/"
                # qgis_path = "C:/OSGeo4W/"
                # qgis_path = "C:/Program Files/QGIS 3.30.1"
                qgis_path = "C:/Users/lbdas/anaconda3/envs/pypyqgis/Library/bin"

            """
            # FOR OMSBERG & PRESTON FINAL CODE
            if platform == "win32" or platform == "Windows":
                win_dst = "O:/Projects_Civil3D/"
                prop_dst = f'P:/_Proposals/{str(today.year)}/'
                output_dst = win_dst
                source_shp = "P:/_Information/Humboldt County GIS Data/Source/"
                # qgis_path = "C:/OSGeo4W/"
                qgis_path = "C:/Program Files/QGIS 3.30.1"
            """
            # lin_dst = "/media/storage/JavaTest/Destination/"
            # output_dst = lin_dst
            # source_shp = "/media/storage/JavaTest/Source/"
            # qgis_path = "/usr"

            source_shp = "P:/_Information/PROJECT CREATION RAW DATA/Source/"
            # output_dst = "P:/_Information/PROJECT CREATION RAW DATA/Destination/"
            if other_proj:
                output_dst = "P:/_Information/OP_PROJECT_CREATOR/Destination"
            else:
                output_dst = "O:/"


            # source_shp = "D:/JavaTest/Source/"
            # output_dst = "D:/JavaTest/Destination/"

            feedback.setProgress(9)

            prop_path_loc = f'{output_dst}_Proposals/{str(today.year)}/'
            contract_path_loc = f'{output_dst}Projects_Civil3D/'
            if not proj_type:
                file_path_loc = f'{contract_path_loc}{str(today.year)[-2:]}-'
            else:
                file_path_loc = prop_path_loc
                proj_num_last = find_highest_proposal_number(file_path_loc)
                proposal_num = proj_num_last + 1
                year_dbl = str(today.year)
                year_dbl_clip = year_dbl[-2:]
                proj_num = f'E{year_dbl_clip}-{proposal_num}'

            # Define the destination files
            destination_shp = f"{file_path_loc}{proj_num}_{client_name}/gis/PROJECT SHAPEFILES/"
            destination_ras = f"{file_path_loc}{proj_num}_{client_name}/gis/GEOREF_RASTER/"
            destination_gis = f"{file_path_loc}{proj_num}_{client_name}/gis/"
            dwg_folder = f"{file_path_loc}{proj_num}_{client_name}/dwg/"
            prj_folder = f"{file_path_loc}{proj_num}_{client_name}/"

            # Create shapefile and raster folders if they do not exist
            check_folder_prj(prj_folder, source_shp)
            check_folder_create(destination_shp)
            check_folder_create(destination_ras)
            check_folder_create(dwg_folder)

            # Define the file location variables (SOURCES)
            parcel_src = f'{source_shp}Parcels/HumCo_Parcels.shp'
            road_src = f'{source_shp}Roads/HumCo_Road_CL.shp'
            stream_src = f'{source_shp}Streams/HumCo_Streams.shp'
            dem_1m_bound = f'{source_shp}DEM_Files/1M_USGS_DEM-Vector Footprint.shp'
            source_1m_dem = f'{source_shp}DEM_Files/1M_USGS_DEM.tif'
            source_dem = f'{source_shp}DEM_Files/HUMBOLDT COUNTY - MERGED_FEET_try2.tif'
            naip_tiles = f'{source_shp}NAIP_JP2/NAIP_TILE-INDEX_2022-2225.shp'
            naip_jp2 = f'{source_shp}NAIP_JP2/'

            # Define the output location for the shapefiles
            selected_dst = f'{destination_shp}{proj_num}_PROJECT PARCEL-2225.shp'
            adjacent_dst = f'{destination_shp}{proj_num}_ADJACENT-2225.shp'
            buffer_dst = f'{destination_shp}{proj_num}_BUFFER PARCELS-2225.shp'
            surrounding_dst = f'{destination_shp}{proj_num}_SURROUNDING PARCELS-2225.shp'
            road_dst = f'{destination_shp}{proj_num}_ROAD CL-2225.shp'
            streams_dst = f'{destination_shp}{proj_num}_STREAMS-2225.shp'
            city_dst = f'{destination_shp}{proj_num}_City_Limits-2225.shp'
            zoning_dst = f'{destination_shp}{proj_num}_Zoning-2225.shp'
            planning_dst = f'{destination_shp}{proj_num}_Planning-2225.shp'
            service_dst = f'{destination_shp}{proj_num}_Service_Districts-2225.shp'
            public_dst = f'{destination_shp}{proj_num}_Public_Lands-2225.shp'
            williamson_dst = f'{destination_shp}{proj_num}_Williamson_Act-2225.shp'
            fire_dst = f'{destination_shp}{proj_num}_Fire_Districts-2225.shp'
            coastal_dst = f'{destination_shp}{proj_num}_Coastal_Zone-2225.shp'
            fema_dst = f'{destination_shp}{proj_num}_FEMA-2225.shp'
            slope_stab_dst = f'{destination_shp}{proj_num}_Slope_Stability-2225.shp'
            slope_stab_bay = f'{destination_shp}{proj_num}_Slope_Stability_BAY-2225.shp'
            alquist_pri_dst = f'{destination_shp}{proj_num}_AlquistPriolo_Zone-2225.shp'
            ag_lands_dst = f'{destination_shp}{proj_num}_AgLands-2225.shp'
            bio_res_dst = f'{destination_shp}{proj_num}_Biological_Resources-2225.shp'
            liquefaction_dst = f'{destination_shp}{proj_num}_LiquefactionArea-2225.shp'

            # Define the output location for the rasters
            destination_1m_dem = f'{destination_ras}{proj_num}_1M_USGS_DEM-CLIPPED-2225.tif'
            destination_dem = f'{destination_ras}{proj_num}_HumCo_10M_DEM-CLIPPED-2225.tif'
            goog_geo_dst = f'{destination_ras}{proj_num}_GoogleGeoRef-temp.tif'
            goog_geo2225 = f'{destination_ras}{proj_num}_GoogleGeoRef-2225.tif'
            naip_dst = f'{destination_ras}{proj_num}_NAIP_2022-CLIPPED-2225.tif'
            slope_per = f'{destination_ras}{proj_num}_SLOPE(PERCENT).tif'
            slope_deg = f'{destination_ras}{proj_num}_SLOPE(DEGREE).tif'
            naip_temp = f'{destination_shp}{proj_num}_TEMP NAIP LAYER.tif'

            # Define the layer style template location
            uri_v1 = f'{source_shp}LayerStyles/streams.qml'
            uri_v2 = f'{source_shp}LayerStyles/road_cl.qml'
            uri_v3 = f'{source_shp}LayerStyles/buffer.qml'
            uri_v4 = f'{source_shp}LayerStyles/surround.qml'
            uri_v5 = f'{source_shp}LayerStyles/adjacent.qml'
            uri_v6 = f'{source_shp}LayerStyles/proj_par.qml'
            uri_v7 = f'{source_shp}LayerStyles/contours2.qml'
            uri_v8 = f'{source_shp}LayerStyles/contours10.qml'
            uri_v9 = f'{source_shp}LayerStyles/contours20.qml'
            uri_v10 = f'{source_shp}LayerStyles/contours40.qml'
            uri_v11 = f'{source_shp}LayerStyles/contours100.qml'
            percent_style = f'{source_shp}LayerStyles/slope_percent.qml'

            feedback.setProgress(10)

            # Set CRS of currently open file
            project = QgsProject.instance()
            crs = QgsCoordinateReferenceSystem("EPSG:2225")
            project.setCrs(crs)

            # Set save options
            save_opt = QgsVectorFileWriter.SaveVectorOptions()
            save_opt.driverName = 'ESRI Shapefile'
            save_opt.onlySelectedFeatures = True
            save_opt.fileEncoding = 'utf-8'

            # Create the layer group
            root1 = project.layerTreeRoot()
            group3 = root1.addGroup("TOPOGRAPHY (CONTOURS)")
            group3.setItemVisibilityChecked(False)
            group1 = root1.addGroup("BACKGROUND LAYERS")
            group1.setItemVisibilityChecked(False)
            group2 = root1.addGroup("SATELLITE IMAGERY")
            group2.setItemVisibilityChecked(True)

            parcels = QgsVectorLayer(parcel_src, "HumCo Parcels", "ogr")
            parcels.setCrs(crs)
            roads = QgsVectorLayer(road_src, "HumCo Roads", "ogr")
            roads.setCrs(crs)
            streams = QgsVectorLayer(stream_src, "HumCo Streams", "ogr")
            streams.setCrs(crs)

            feedback.setProgress(12)

            # Select project parcel
            expression = QgsExpression(f"\"APN_12\"='{proj_apn}'")
            request = QgsFeatureRequest(expression)
            features = parcels.getFeatures(request)
            selected_feature = next(features, None)
            parcels.selectByExpression(expression.expression(), QgsVectorLayer.SetSelection)

            # Ensure the output CRS is EPSG:2225, export the selected parcel, add to project
            crs = QgsCoordinateReferenceSystem(2225, QgsCoordinateReferenceSystem.EpsgCrsId)
            _writer = QgsVectorFileWriter.writeAsVectorFormatV3(parcels, selected_dst, QgsProject.instance().
                                                                transformContext(), save_opt)
            self.selected_parcel = QgsVectorLayer(selected_dst, "PROJECT PARCEL", "ogr")
            self.selected_parcel.setCrs(crs)
            self.selected_parcel.loadNamedStyle(uri_v6)
            self.selected_parcel.triggerRepaint()
            del _writer

            # Get the selected parcel's centroid and create the buffer zones for project data extraction
            parcel_center = selected_feature.geometry().centroid()
            selected_parcel_buffer = parcel_center.buffer(buffer_radius, 30)
            adjacent_parcel_buffer = selected_feature.geometry().buffer(20, 30)
            dem_radius_buffer = selected_feature.geometry().buffer(buffer_dem, 4)

            # Gather adjacent parcels and export to new shapefile, add to project
            selected_geometry = selected_feature.geometry()
            parcels.selectByExpression(f"touches($geometry, geom_from_wkt('{selected_geometry.asWkt()}'))")
            if parcels.selectedFeatureCount() > 0:
                _writer = QgsVectorFileWriter.writeAsVectorFormatV3(parcels, adjacent_dst, QgsProject.instance().
                                                                    transformContext(), save_opt)
                self.adjacent_parcels = QgsVectorLayer(adjacent_dst, "ADJACENT PARCELS", "ogr")
                self.adjacent_parcels.setCrs(crs)
                self.adjacent_parcels.loadNamedStyle(uri_v5)
                self.adjacent_parcels.triggerRepaint()
                del _writer

            # Gather surrounding parcels within 5000 feet and export to new shapefile
            parcels.selectByExpression(
                f"intersects($geometry, geom_from_wkt('{selected_parcel_buffer.asWkt()}')) AND NOT touches($geometry, "
                f"geom_from_wkt('{selected_geometry.asWkt()}'))")
            if parcels.selectedFeatureCount() > 0:
                _writer = QgsVectorFileWriter.writeAsVectorFormatV3(parcels, surrounding_dst, QgsProject.instance().
                                                                    transformContext(), save_opt)
                self.surrounding_parcels = QgsVectorLayer(surrounding_dst, "SURROUNDING PARCELS", "ogr")
                self.surrounding_parcels.setCrs(crs)
                self.surrounding_parcels.loadNamedStyle(uri_v4)
                self.surrounding_parcels.triggerRepaint()
                del _writer

            # Gather ROADS within 5000 feet and export to new shapefile
            roads.selectByExpression(f"intersects($geometry, geom_from_wkt('{selected_parcel_buffer.asWkt()}'))")
            if roads.selectedFeatureCount() > 0:
                _writer = QgsVectorFileWriter.writeAsVectorFormatV3(roads, road_dst, QgsProject.instance().
                                                                    transformContext(), save_opt)
                self.roads_proj = QgsVectorLayer(road_dst, "ROAD CENTERLINE", "ogr")
                self.roads_proj.setCrs(crs)
                self.roads_proj.loadNamedStyle(uri_v2)
                self.roads_proj.triggerRepaint()
                del _writer

            # Gather STREAMS within 5000 feet and export to new shapefile
            streams.selectByExpression(f"intersects($geometry, geom_from_wkt('{selected_parcel_buffer.asWkt()}'))")
            if streams.selectedFeatureCount() > 0:
                _writer = QgsVectorFileWriter.writeAsVectorFormatV3(streams, streams_dst, QgsProject.instance().
                                                                    transformContext(), save_opt)
                self.streams_proj = QgsVectorLayer(streams_dst, "STREAMS", "ogr")
                self.streams_proj.setCrs(crs)
                self.streams_proj.loadNamedStyle(uri_v1)
                self.streams_proj.triggerRepaint()
                del _writer

                project.addMapLayer(self.streams_proj)
                project.addMapLayer(self.roads_proj)
                project.addMapLayer(self.surrounding_parcels)
                project.addMapLayer(self.adjacent_parcels)
                project.addMapLayer(self.selected_parcel)

            feedback.setProgress(15)

            # Loads the remaining shapefiles for Humboldt County, clips and exports based on buffer
            file_list = [
                ('City Limits', 'City Limits.shp', '_City_Limits-2225.shp'),
                ('Zoning', 'HumCo_Zoning.shp', '_Zoning-2225.shp'),
                ('Planning', 'HumCo_Planning.shp', '_Planning-2225.shp'),
                ('Service Districts', 'HumCo_Service_Districts.shp', '_Service_Districts-2225.shp'),
                ('Public Lands', 'HumCo_Public_Lands.shp', '_Public_Lands-2225.shp'),
                ('Williamson Act', 'HumCo_Williamson_Act.shp', '_Williamson_Act-2225.shp'),
                ('Fire Districts', 'HumCo_Fire_Districts.shp', '_Fire_Districts-2225.shp'),
                ('Coastal Zone', 'HumCo_Coastal_Zone.shp', '_Coastal_Zone-2225.shp'),
                ('FEMA', 'HumCo_FEMA.shp', '_FEMA-2225.shp'),
                ('Slope Stability Zones_County', 'SlopeStability_HUM.shp', '_Slope_Stability-2225.shp'),
                ('Slope Stability Zones_HumBay', 'SlopeStab_BAY.shp', '_Slope_Stability_BAY-2225.shp'),
                ('Alquist Priolo Zones', 'AlquistPriolo.shp', '_AlquistPriolo_Zone-2225.shp'),
                ('Agricultural Lands', 'AgLands.shp', '_AgLands-2225.shp'),
                ('Biological Resource Areas', 'Bio_Res.shp', '_Biological_Resources-2225.shp'),
                ('Liquefaction Zones', 'Liquefaction.shp', '_LiquefactionAreas-2225.shp')
            ]

            file_dict = {}

            for file in file_list:
                layer_name, src_filename, dst_filename = file
                src_file = f'{source_shp}{layer_name}/{src_filename}'
                dst_file = f'{destination_shp}{proj_num}{dst_filename}'

                # Load the shapefile
                layer = QgsVectorLayer(src_file, "temp_layer", "ogr")

                # Select features within the buffer
                layer.selectByExpression(f"intersects($geometry, geom_from_wkt('{selected_parcel_buffer.asWkt()}'))")

                if layer.selectedFeatureCount() > 0 and layer.isValid():
                    # Export to new shapefile
                    _writer = QgsVectorFileWriter.writeAsVectorFormatV3(layer, dst_file, project.transformContext(),
                                                                        save_opt)
                    del _writer

            feedback.setProgress(17)

            # Add background vector layers to project
            layer_info = [
                (liquefaction_dst, "LIQUEFACTION AREAS"),
                (bio_res_dst, "BIOLOGICAL RESOURCES"),
                (ag_lands_dst, "AGRICULTURAL LANDS"),
                (alquist_pri_dst, "ALQUIST-PRIOLO ZONES"),
                (slope_stab_bay, "SLOPE STABILITY (HUMBOLDT BAY)"),
                (slope_stab_dst, "SLOPE STABILITY (COUNTY)"),
                (city_dst, "CITY BOUNDARY"),
                (zoning_dst, "ZONING"),
                (planning_dst, "PLANNING BOUNDARIES"),
                (service_dst, "SERVICE DISTRICTS"),
                (public_dst, "PUBLIC LANDS"),
                (williamson_dst, "WILLIAMSON ACT AREAS"),
                (fire_dst, "FIRE DISTRICT"),
                (coastal_dst, "COASTAL ZONE"),
                (fema_dst, "FLOOD ZONE")
            ]

            layer_list = []

            for path, name in layer_info:
                if os.path.exists(path):
                    layer = QgsVectorLayer(path, name, "ogr")
                    if layer.featureCount() > 0:
                        # Load the new shapefile
                        layer.setCrs(crs)
                        layer.loadNamedStyle(uri_v3)  # Replace with your style file
                        layer.triggerRepaint()
                        project.addMapLayer(layer, False)
                        layer_list.append(layer)
                        group1.addLayer(layer)
                else:
                    print(f"File not found: {path}")

            feedback.setProgress(20)

            # Time to load the raster layers into the project!
            # Google Earth goes first
            url = "mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}"
            uri = "type=xyz&zmin=0&zmax=23&url=https://" + requests.utils.quote(url)
            goog_layer = QgsRasterLayer(uri, 'Google Satellite', 'wms')
            if not goog_layer.isValid():
                print("Layer failed to load!")
                print("Error summary: ", goog_layer.error().summary())
                print("Detailed error message: ", goog_layer.error().message())
                print(goog_layer.error())
            else:
                # Add the layer to the QGIS project
                project.addMapLayer(goog_layer, False)
                group2.insertChildNode(2, QgsLayerTreeLayer(goog_layer))

            feedback.setProgress(22)

            # Get extents and export clipped GeoTIFF
            extent_layer = dem_radius_buffer.boundingBox()
            provider = goog_layer.dataProvider()
            # extent = QgsRectangle(extent_layer.extent())
            x_pixels = int(extent_layer.width() * 3.2808)
            y_pixels = int(extent_layer.height() * 3.2808)

            # Set input and output CRS
            crs_src = QgsCoordinateReferenceSystem(goog_layer.crs())  # EPSG of Google Earth Satellite (3857)
            crs_dst = QgsCoordinateReferenceSystem("EPSG:2225")  # EPSG of target crs

            # Code for QGIS 3.xx - QgsCoordinateTransform is different in v 2.xx #
            xform_dst_to_src = QgsCoordinateTransform(crs_dst, crs_src, QgsProject.instance())
            projected_extent = xform_dst_to_src.transformBoundingBox(extent_layer)

            pipe = QgsRasterPipe()
            pipe.set(provider.clone())

            file_writer = QgsRasterFileWriter(goog_geo_dst)
            file_writer.Mode(0)
            file_writer.setMaxTileWidth(6500)
            file_writer.setMaxTileHeight(6500)

            feedback.setProgress(25)

            file_writer.writeRaster(pipe, x_pixels, y_pixels, projected_extent, crs_src,
                                    project.transformContext())

            feedback.setProgress(35)

            # Define the target CRS
            dst_crs = crs

            # Open the input raster dataset
            src_layer = QgsRasterLayer(goog_geo_dst)

            feedback.setProgress(40)

            # Get the transform and dimensions of the input dataset
            src_transform = src_layer.transformContext()
            src_width = src_layer.width()
            src_height = src_layer.height()

            params = {
                'INPUT': src_layer,
                'TARGET_CRS': dst_crs,
                'OUTPUT': goog_geo2225
            }

            processing.run("gdal:warpreproject", params)

            feedback.setProgress(45)

            # Add aerial Google raster to project
            rlayer2 = QgsRasterLayer(goog_geo2225, "Parcel Overview-GOOG")
            project.addMapLayer(rlayer2, False)
            group2.insertChildNode(1, QgsLayerTreeLayer(rlayer2))

            feedback.setProgress(50)

            # It's NAIP time babyyyyy [transfer complete; needs testing and switching to QGS functionality]
            # Load vector data and select intersecting features in order to import NAIP imagery
            tiles = gpd.read_file(naip_tiles)
            project_parcel = gpd.read_file(selected_dst)

            poly = project_parcel.iloc[0]
            naip_buffer = 1000
            buffer = poly.geometry.buffer(naip_buffer)
            selected_tiles = tiles[tiles.intersects(buffer) | tiles.within(buffer)].copy()
            target_crs = rasterio.crs.CRS.from_epsg(2225)
            src_crs = rasterio.crs.CRS.from_epsg(3857)

            feedback.setProgress(55)

            def check_bounds_orientation(bbox1, bbox2):
                """Check if two bounding boxes have the same orientation"""
                if bbox1[0] - bbox1[2] == bbox2[0] - bbox2[2]:
                    return True
                elif bbox1[1] - bbox1[3] == bbox2[1] - bbox2[3]:
                    bbox1 = (bbox1[1], bbox1[0], bbox1[3], bbox1[2])
                    return disjoint_bounds(bbox1, bbox2)
                else:
                    # Switch left and right coordinates of bbox1
                    bbox1 = (bbox1[2], bbox1[1], bbox1[0], bbox1[3])
                    if disjoint_bounds(bbox1, bbox2):
                        return True
                    else:
                        # Raise an exception if the bounds are still disjoint
                        raise ValueError("Bounds must both have the same orientation")

            feedback.setProgress(58)

            # Find all raster files within the buffer
            raster_files = []
            for index, row in selected_tiles.iterrows():
                raster_path = f"{naip_jp2}{row['filename']}"
                if check_bounds_orientation(buffer.bounds, rasterio.open(raster_path).bounds):
                    raster_files.append(raster_path)

            feedback.setProgress(60)

            # Merge the list of rasters into a single raster
            if len(raster_files) != 1:
                merged_data, merged_transform = rasterio.merge.merge(raster_files)
            else:
                # If there is only one file, read the raster data and transform directly
                with rasterio.open(raster_files[0]) as src:
                    merged_data = src.read()
                    merged_transform = src.transform
            # Write the merged raster to file
            with rasterio.open(naip_temp, 'w', driver='GTiff', width=merged_data.shape[2], height=merged_data.shape[1],
                               count=merged_data.shape[0], dtype=merged_data.dtype, crs=src_crs,
                               transform=merged_transform, nodata=0, photometric='rgb') as dest:
                dest.write(merged_data)
                dest.close()

            feedback.setProgress(63)

            with rasterio.open(naip_temp, driver='GTiff', photometric='jp2k') as src:
                src_transform = src.transform
                src_nodata = src.nodata
                src_crs = src.crs

                # Transform the buffer to the same CRS as the raster
                buffer_gdf = gpd.GeoDataFrame(index=[0], crs=target_crs, geometry=[buffer])
                buffer_gdf = buffer_gdf.to_crs(src.crs)

                feedback.setProgress(65)

                # Get the bounds of the buffer
                left, bottom, right, top = buffer_gdf.bounds.iloc[0]

                # Get the window of the raster that intersects with the buffer
                window = rasterio.windows.from_bounds(left=left, bottom=bottom, right=right, top=top,
                                                      transform=src_transform)

                feedback.setProgress(69)

                # Read the raster data within the window
                raster_data = src.read(window=window)

                # Set the NoData values to NaN
                raster_data = np.where(raster_data == src_nodata, np.nan, raster_data)

                # Get the width and height of the clipped raster
                out_width = window.width
                out_height = window.height

                # Calculate the transform of the clipped raster
                src_transform = rasterio.transform.from_bounds(left, bottom, right, top, out_width, out_height)

                feedback.setProgress(70)

                # Save the clipped raster data to a new file
                # raster_datasets = raster_datasets.append(raster_data)
                with rasterio.open(naip_dst, 'w', driver='GTiff', width=window.width, height=window.height,
                                   count=raster_data.shape[0], dtype=raster_data.dtype, crs=src_crs,
                                   transform=src_transform,
                                   nodata=np.nan, photometric='rgb') as dst:
                    dst.write(raster_data)
                src.close()

            feedback.setProgress(72)

            # Add aerial NAIP raster to project
            rlayer3 = QgsRasterLayer(naip_dst, "NAIP Imagery-Parcel Overview")
            project.addMapLayer(rlayer3, False)
            group2.insertChildNode(3, QgsLayerTreeLayer(rlayer3))

            feedback.setProgress(74)

            # Now let's handle the DEM, contours, and slope
            # Check which DEM (10M or 1M) the parcel is in
            gdf = gpd.read_file(dem_1m_bound)
            for index, row in gdf.iterrows():
                shapely_polygon = row['geometry']
                polygon_wkt = dumps(shapely_polygon)  # Convert Shapely geometry to WKT
                polygon_qgs = QgsGeometry.fromWkt(polygon_wkt)  # Convert WKT to QgsGeometry
                if parcel_center.within(polygon_qgs):
                    dem1m = True
                    raster_file = destination_1m_dem
                    input_epsg = get_dem_raster(source_1m_dem, selected_dst, raster_file)
                else:
                    dem1m = False
                    raster_file = destination_dem
                    input_epsg = get_dem_raster(source_dem, selected_dst, raster_file)

            feedback.setProgress(77)

            # Create a contour shapefile from the clipped DEM raster
            # input_epsg is defined in the previous code blocks
            with rasterio.open(raster_file) as src:
                elevation_values = src.read(1)
                transform = src.transform
                src.close()

            feedback.setProgress(78)

            intervals = [2, 10, 20, 40, 100]
            output_epsg = 2225

            for interval in intervals:

                # Calculate the elevation range
                elevation_range = np.max(elevation_values) - np.min(elevation_values)

                # Skip the interval if the elevation range is less than the interval
                if elevation_range < interval:
                    continue

                shapefile = destination_shp + "temp.shp"
                elevations = [e for e in range(0, int(np.max(elevation_values)) + interval, interval)]

                driver = ogr.GetDriverByName('ESRI Shapefile')

                # Create the output DataSource
                data_source = driver.CreateDataSource(shapefile)

                # Create the spatial reference
                srs = osr.SpatialReference()
                srs.ImportFromEPSG(input_epsg)

                # Create the layer
                layer = data_source.CreateLayer("contours", srs, ogr.wkbLineString25D)

                # Add the 'elevation' field
                field_elevation = ogr.FieldDefn("ELEV", ogr.OFTReal)
                layer.CreateField(field_elevation)

                for elevation in elevations:
                    contours = skimage.measure.find_contours(elevation_values, elevation)
                    for contour in contours:
                        contour_line = ogr.Geometry(ogr.wkbLineString25D)
                        for y, x in contour:
                            contour_line.AddPoint(x * transform[0] + transform[2], y * transform[4] + transform[5],
                                                  elevation)

                        # Create the feature
                        feature = ogr.Feature(layer.GetLayerDefn())
                        # Set the attributes
                        feature.SetField("elevation", elevation)
                        # Set the geometry
                        feature.SetGeometry(contour_line)
                        # Create the feature in the layer (shapefile)
                        layer.CreateFeature(feature)

                        # Destroy the feature to free resources
                        feature.Destroy()

                # Destroy the data source to free resources
                data_source.Destroy()

                # Now read the created shapefile with geopandas, reproject and save it to the final file
                gdf = gpd.read_file(shapefile)
                gdf = gdf.set_crs(input_epsg)
                gdf = gdf.to_crs('epsg:' + str(output_epsg))
                gdf.to_file(f"{destination_shp}{proj_num}_CONTOURS_{interval}ft-{output_epsg}.shp",
                            driver='ESRI Shapefile')

            feedback.setProgress(90)

            contour_1 = f"{destination_shp}{proj_num}_CONTOURS_2ft-2225.shp"
            contour_2 = f"{destination_shp}{proj_num}_CONTOURS_10ft-2225.shp"
            contour_3 = f"{destination_shp}{proj_num}_CONTOURS_20ft-2225.shp"
            contour_4 = f"{destination_shp}{proj_num}_CONTOURS_40ft-2225.shp"
            contour_5 = f"{destination_shp}{proj_num}_CONTOURS_100ft-2225.shp"
            contour_6 = f"{destination_shp}{proj_num}_CONTOURS_200ft-2225.shp"

            # Create a list of vector layers, including the contour layers
            vector_layers = [
                (streams_dst, "STREAMS", uri_v1),
                (road_dst, "ROAD CENTERLINE", uri_v2),
                (buffer_dst, "PARCELS SELECTED BY BUFFER", uri_v3),
                (surrounding_dst, "SURROUNDING PARCELS", uri_v4),
                (adjacent_dst, "ADJACENT PARCELS", uri_v5),
                (selected_dst, "PROJECT PARCEL", uri_v6),
            ]

            feedback.setProgress(91)

            contour_files = [
                (contour_1, "CONTOURS-2FT", uri_v7),
                (contour_2, "CONTOURS-10FT", uri_v8),
                (contour_3, "CONTOURS-20FT", uri_v9),
                (contour_4, "CONTOURS-40FT", uri_v10),
                (contour_5, "CONTOURS-100FT", uri_v11),
                (contour_6, "CONTOURS-200FT", uri_v11),
            ]

            # Create QgsVectorLayer objects and add valid layers to the project
            vector_dict = []
            contour_layers = []
            index = 0

            feedback.setProgress(92)

            # Add contour layers to the project
            for contour_file, contour_name, style in contour_files:
                if os.path.exists(contour_file):
                    contour_layers.append((contour_file, contour_name, style))

            for file_path, name, style in contour_layers:
                layer = QgsVectorLayer(file_path, name, "ogr")
                if layer.isValid():
                    index = index + 1
                    project.addMapLayer(layer, False)
                    layer.loadNamedStyle(style, True)
                    group3.insertChildNode(index, QgsLayerTreeLayer(layer))

            feedback.setProgress(93)

            # Slope time
            # Add the DEM raster layer and generate slope (if DEM=1M DEM) and add to the project
            if dem1m:
                # Run the Slope plugin in order to get a slope raster for the project
                input_dem_slope = raster_file
                output_per = gdal.DEMProcessing(slope_per, input_dem_slope, 'slope', computeEdges=True,
                                                slopeFormat='percent')
                output_dem = gdal.DEMProcessing(slope_deg, input_dem_slope, 'slope', computeEdges=True,
                                                slopeFormat='degree')
                output_per = None
                output_dem = None

                r_layer1 = QgsRasterLayer(destination_1m_dem, "1M USGS DEM (1/9 ARC-SECOND)")
                if r_layer1.isValid():
                    QgsProject.instance().addMapLayer(r_layer1, False)
                    group2.insertChildNode(4, QgsLayerTreeLayer(r_layer1))
                    rlayer4 = QgsRasterLayer(slope_deg, "Slope Raster in Degrees")
                    if rlayer4.isValid():
                        project.addMapLayer(rlayer4, False)
                        group2.insertChildNode(5, QgsLayerTreeLayer(rlayer4))

                    rlayer5 = QgsRasterLayer(slope_per, "Slope Raster in Percent")
                    if rlayer5.isValid():
                        project.addMapLayer(rlayer5, False)
                        group2.insertChildNode(5, QgsLayerTreeLayer(rlayer5))
                        rlayer5.loadNamedStyle(percent_style)
            else:
                r_layer1 = QgsRasterLayer(destination_dem, "10M HUM_CO USGS DEM (1/3 ARC-SECOND)")
                if r_layer1.isValid():
                    QgsProject.instance().addMapLayer(r_layer1, False)
                    group2.insertChildNode(4, QgsLayerTreeLayer(r_layer1))

            # os.remove(goog_geo_dst)

            feedback.setProgress(96)

            project_file = f"{destination_gis}{client_name}_PROJECT MASTER.qgz"
            # project.writePath(project_file)
            # project.write()
            # QgsProject.instance().layersAdded.connect(layers_added)

            save_status = project.write(project_file)

            if not save_status:
                QgsMessageLog.logMessage(f"Error saving project to {project_file}", 'MyPlugin', Qgis.Critical)

            feedback.setProgress(100)
            return {project_file}

        # Now, for the program modules...
        # Search through the /_Proposals/ folder, find the highest project number, and create a new proposal
        def find_highest_proposal_number(folder_path):
            proposal_numbers = []
            for filename in os.listdir(folder_path):
                if filename.startswith("E23-"):
                    proposal_number = int(filename.split("_")[0][4:])
                    proposal_numbers.append(proposal_number)
            return max(proposal_numbers)

        def vector_proc(file_in, file_out):
            params_vector = {
                'INPUT': file_in,
                'OVERLAY': buffer_layer,
                'OUTPUT': file_out
            }

            processing.run("native:clip", params_vector)

        # Create sub-folders for project
        def check_folder_create(folder_name):
            if not os.path.exists(folder_name):
                os.makedirs(folder_name)

        # Create project folder
        def check_folder_prj(folder_name, src):
            new_prj_src = f'{src}_New Client Template_E23-XXXX_CLIENT NAME'
            if not os.path.exists(folder_name):
                shutil.copytree(new_prj_src, folder_name)

        def loadXYZ(url, name):
            rasterLyr = QgsRasterLayer("type=xyz&url=" + url, name, "wms")
            QgsProject.instance().addMapLayer(rasterLyr)

        # Export Shapefiles based on buffer from parcel centroid
        def shapefile_clip_exp(shp_in, shp_out, centroid):
            # src = gpd.read_file(shp_in)
            src = shp_in
            buff = centroid.buffer(buffer_radius)
            selected = src[src.intersects(buff) | src.within(buff)].copy()
            clip = selected.copy()
            clip.geometry = clip.intersection(buff)
            if len(clip) > 0:
                clip.to_file(shp_out)

        def get_dem_raster(source, parcel, destination):
            with rasterio.open(source) as src:
                src_transform = src.transform
                src_nodata = src.nodata
                src_crs = src.crs

                # Calculate the buffer
                project_parcel = gpd.read_file(parcel)
                poly = project_parcel.iloc[0]
                buffer = poly.geometry.buffer(buffer_dem)

                # Transform the buffer to the same CRS as the raster
                buffer_gdf = gpd.GeoDataFrame(index=[0], crs='epsg:2225', geometry=[buffer])
                buffer_gdf = buffer_gdf.to_crs(src_crs)

                # Get the bounds of the buffer
                left, bottom, right, top = buffer_gdf.bounds.iloc[0]

                # Get the window of the raster that intersects with the buffer
                window = rasterio.windows.from_bounds(left=left, bottom=bottom, right=right, top=top,
                                                      transform=src_transform)

                # Read the raster data within the window
                raster_data = src.read(1, window=window)

                # Set the NoData values to NaN
                raster_data = np.where(raster_data == src_nodata, np.nan, raster_data)

                # Get the width and height of the clipped raster
                out_width = window.width
                out_height = window.height

                # Calculate the transform of the clipped raster
                src_transform = rasterio.transform.from_bounds(left, bottom, right, top, out_width, out_height)

                # Save the clipped raster data to a new file
                with rasterio.open(destination, 'w', driver='GTiff', width=window.width, height=window.height,
                                   count=1, dtype=raster_data.dtype, crs=src_crs, transform=src_transform,
                                   nodata=np.nan) as dst:
                    dst.write(raster_data, 1)
                epsg_code = src_crs.to_string()
                epsg_in = int(epsg_code.split(":")[-1])
                return epsg_in

        project_file_loc = execute_code()
        return {self.OP_PROJECT_FILE: project_file_loc}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Omsberg and Preston Project Creator'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return procplug1Algorithm()
